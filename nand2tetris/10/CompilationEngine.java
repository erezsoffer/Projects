import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Gets its input from a JackTokenizer, and emits its output to an output file.
 * The output is generated by a series of compilexxx routines,
 * structured according to the grammar rules that define xxx.
 * Each compilexxx routine is responsible for handling all the tokens that make up xxx,
 * advancing the tokenizer exactly beyond these tokens, and outputing the parsing of xxx.
 *
 * @authors Yaheli and Erez
 */
public class CompilationEngine {
    
    JackTokenizer jt;
    BufferedWriter bw;
    String currentToken;
    String tokenType;
    String tabs = "";
    
    /**
     * Creates a new compilation engine with the given input and output.
     * The next routine called (by the JackAnalyzer module) must be compileClass.
     * 
     * @param inputFile
     * @param outputFile
     */
    public CompilationEngine(File inputFile, File outputFile) {
        try {
            bw = new BufferedWriter(new FileWriter(outputFile));
            jt = new JackTokenizer(inputFile);
            if (jt.hasMoreTokens()) {
                jt.advance();
                currentToken = jt.currentToken;
                tokenType = jt.tokenType();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /** 
     * A helper method that handles the current token, and advances to get the next token.
     * 
     * @param expectedToken
     */
    public void process(String expectedToken) {
        if ((expectedToken.equals("identifier") && (tokenType.equals(expectedToken)))) {
            printXMLToken(currentToken);
        }
        else if (!expectedToken.equals("identifier") && (currentToken.equals(expectedToken))) {
            switch (currentToken) {
                case "<":
                    printXMLToken("&lt;");
                    break;
                case ">":
                    printXMLToken("&gt;");
                    break;
                case "&":
                    printXMLToken("&amp;");
                    break;
                default:
                    printXMLToken(currentToken);
                    break;
            }
        } else {
            System.out.print(expectedToken + currentToken + " Syntax Error\n");
        }
        // advance jt
        if (jt.hasMoreTokens()) {
            jt.advance();
            currentToken = jt.currentToken;
            tokenType = jt.tokenType();
        } else {
            currentToken = "";
            tokenType = "";
        } 
    }

    /**
     * Prints the token in the .xml format.
     * 
     * @param token
     */
    public void printXMLToken(String token) {
        try {
            bw.write(tabs + "<" + jt.tokenType() + "> " + token + " </" + jt.tokenType() + ">");
            bw.newLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Prints the tagRule in the .xml format.
     * 
     * @param tagRule
     * @param closeTag
     */
    public void printXMLTagRules(String tagRule, String closeTag){
        try {
            bw.write(tabs + "<" + closeTag + tagRule + ">");
            bw.newLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Compiles a complete class.
     * 
     */
    public void compileClass() {
        printXMLTagRules("class", "");
        process("class");
        process("identifier");
        process("{");
        while (currentToken.matches("^static|field$")) {
            compileClassVarDec();
        }
        while (currentToken.matches("^constructor|function|method$")) {
            compileSubroutine();
        }
        process("}");
        printXMLTagRules("class", "/");
    }

    /**
     * Compiles a static variable declaration, or a field declaration.
     * 
     */
    public void compileClassVarDec() {
        tabs += "  ";
        printXMLTagRules("classVarDec", "");
        if (currentToken.equals("static")) {
            process("static");
        } else {
            process("field");
        }

        if (currentToken.matches("^int|char|boolean$")) {
            process(currentToken);
        } else {
            process("identifier"); 
        }
        process("identifier"); //varName
        while (currentToken.equals(",")) {
            process(",");
            process("identifier"); //varName
        }
        process(";");
        printXMLTagRules("classVarDec", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a complete method, function, or constructor.
     * 
     */
    public void compileSubroutine() {
        tabs += "  ";
        printXMLTagRules("subroutineDec", "");
        switch (currentToken) {
            case "constructor":
                process("constructor");
                break;
            case "function":
                process("function");
                break;
            default:
                process("method");
                break;
        }
        if (currentToken.equals("void")) {
            process(currentToken);
        } else {
            process("identifier"); 
        }
        process("identifier"); 
        process("(");
        compileParameterList();
        process(")");
        compileSubroutineBody();
        printXMLTagRules("subroutineDec", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a (possibly empty) parameter list.
     * Does not handle the enclosing parentheses tokens ( and ).
     * 
     */
    public void compileParameterList() {
        tabs += "  ";
        printXMLTagRules("parameterList", "");
        boolean moreThan1 = false;
        while (!currentToken.equals(")")) {
            if (moreThan1) {
                process(",");
            } else {
                moreThan1 = true;
            }
            if (currentToken.matches("^int|char|boolean$")) {
                process(currentToken);
            } else {
                process("identifier"); 
            }
            process("identifier"); //varName
        }
        printXMLTagRules("parameterList", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a subroutine's body.
     * 
     */
    public void compileSubroutineBody() {
        tabs += "  ";
        printXMLTagRules("subroutineBody", "");
        process("{");
        while (currentToken.equals("var")) {
            compileVarDec();
        }
        compileStatements();
        process("}");
        printXMLTagRules("subroutineBody", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a var declaration.
     * 
     */
    public void compileVarDec() {
        tabs += "  ";
        printXMLTagRules("varDec", "");
        process("var");
        if (currentToken.matches("^int|char|boolean$")) {
            process(currentToken);
        } else {
            process("identifier"); 
        }
        process("identifier"); //varName
        while (currentToken.equals(",")) {
            process(",");
            process("identifier"); //varName
        }
        process(";");
        printXMLTagRules("varDec", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a sequence of statements.
     * Does not handle the enclosing curly bracket tokens { and }.
     * 
     */
    public void compileStatements() {
        tabs += "  ";
        printXMLTagRules("statements", "");
        while (currentToken.matches("^let|if|while|do|return$")) {
            switch (currentToken) {
                case "let":
                    compileLet();
                    break;
                case "if":
                    compileIf();
                    break;
                case "while":
                    compileWhile();
                    break;
                case "do":
                    compileDo();
                    break;
                case "return":
                    compileReturn();
                    break;
            }
        }
        printXMLTagRules("statements", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a let statement.
     * 
     */
    public void compileLet() {
        tabs += "  ";
        printXMLTagRules("letStatement", "");
        process("let");
        process("identifier");
        if (currentToken.equals("[")) {
            process("[");
            compileExpression();
            process("]");
        }
        process("=");
        compileExpression();
        process(";");
        printXMLTagRules("letStatement", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles an if statement, possibly with a trailing else clause.
     * 
     */
    public void compileIf() {
        tabs += "  ";
        printXMLTagRules("ifStatement", "");
        process("if");
        process("(");
        compileExpression();
        process(")");
        process("{");
        compileStatements();
        process("}");
        if (currentToken.equals("else")) {
            process("else");
            process("{");
            compileStatements();
            process("}");
        }
        printXMLTagRules("ifStatement", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a while statement.
     * 
     */
    public void compileWhile() {
        tabs += "  ";
        printXMLTagRules("whileStatement", "");
        process("while");
        process("(");
        compileExpression();
        process(")");
        process("{");
        compileStatements();
        process("}");
        printXMLTagRules("whileStatement", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a do statement.
     * 
     */
    public void compileDo() {
        tabs += "  ";
        printXMLTagRules("doStatement", "");
        process("do");
        process(currentToken);
        if (currentToken.equals(".")) {
            process(".");
            process(currentToken);
        }
        process("(");
        compileExpressionList();
        process(")");
        process(";");
        printXMLTagRules("doStatement", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a return statement.
     * 
     */
    public void compileReturn() {
        tabs += "  ";
        printXMLTagRules("returnStatement", "");
        process("return");
        if (!currentToken.equals(";")) {
            compileExpression();
        }
        process(";");
        printXMLTagRules("returnStatement", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles an expression.
     * 
     */
    public void compileExpression() {
        tabs += "  ";
        printXMLTagRules("expression", "");
        compileTerm();
        while (currentToken.matches("^[+\\-*/&|<>=]+$")) {
            process(currentToken);
            compileTerm();
        }
        printXMLTagRules("expression", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a term.
     * If the current token is an identifier, the routine must resolve it into a variable, an array entry, or a subroutine call.
     * A single lookahead token, which may be [, (, or ., suffices to distinguish between the possibilities.
     * Any other token is not part of this term and should not be advanced over.
     * 
     */
    public void compileTerm() {
        tabs += "  ";
        printXMLTagRules("term", "");
        if (tokenType.matches("^integerConstant|stringConstant|keyword$")) {
            process(currentToken);
        } else if (currentToken.matches("^[-~]$")) {
            process(currentToken);
            compileTerm();
        } else if (currentToken.equals("(")) {
            process("(");
            compileExpression();
            process(")");
        } else {
            process("identifier");
            switch (currentToken) {
                case "[":
                    process("[");
                    compileExpression();
                    process("]");
                    break;
                case "(":
                    process("(");
                    compileExpressionList();
                    process(")");
                    break;
                case ".":
                    process(".");
                    process("identifier");
                    process("(");
                    compileExpressionList();
                    process(")");
                    break;
            }
        }
        printXMLTagRules("term", "/");
        tabs.substring(0, tabs.length() - 2);
    }

    /**
     * Compiles a (possibly empty) comma-separated list of expressions.
     * 
     * @return the number of expressions in the list.
     */
    public int compileExpressionList() {
        tabs += "  ";
        printXMLTagRules("expressionList", "");
        int i;
        for (i = 0; !currentToken.equals(")"); i++) {
            if (i > 0) {
                process(",");
            }
            compileExpression();
        }
        printXMLTagRules("expressionList", "/");
        tabs.substring(0, tabs.length() - 2);
        return i;
    }

    /**
     * Closes the BufferedReader.
     * 
     */
    public void close() {
        try {
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
